import "stdlib.airy" :: printf

// Token 类型常量函数
fn TOK_NUMBER() -> u8 { return 0u8; }
fn TOK_PLUS() -> u8 { return 1u8; }
fn TOK_MINUS() -> u8 { return 2u8; }
fn TOK_STAR() -> u8 { return 3u8; }
fn TOK_SLASH() -> u8 { return 4u8; }
fn TOK_PERCENT() -> u8 { return 5u8; }
fn TOK_LPAREN() -> u8 { return 6u8; }
fn TOK_RPAREN() -> u8 { return 7u8; }
fn TOK_EOF() -> u8 { return 8u8; }
fn TOK_ERROR() -> u8 { return 9u8; }

struct Token {
    ty: u8,
    value: i64,
}

// 判断是否为数字字符
fn is_digit(c: u8) -> bool {
    return c >= '0' && c <= '9';
}

// 判断是否为空白字符
fn is_space(c: u8) -> bool {
    return c == ' ' || c == '\t' || c == '\n' || c == '\r';
}

// 词法分析函数
fn lex(text: *const u8, tokens: *mut struct Token, max_tokens: i32) -> i32 {
    let i: i32 = 0;
    let tok_count: i32 = 0;
    
    while (text[i] != 0u8 && tok_count < max_tokens) {
        while (is_space(text[i])) {
            i = i + 1;
        }
        
        if (text[i] == 0u8) {
            break;
        }
        
        if (is_digit(text[i])) {
            let num: i64 = 0i64;
            while (is_digit(text[i])) {
                let digit_u8: u8 = text[i] - '0';
                // 手动转换 u8 到 i64
                let digit: i64 = 0i64;
                if (digit_u8 == 0u8) { digit = 0i64; }
                else if (digit_u8 == 1u8) { digit = 1i64; }
                else if (digit_u8 == 2u8) { digit = 2i64; }
                else if (digit_u8 == 3u8) { digit = 3i64; }
                else if (digit_u8 == 4u8) { digit = 4i64; }
                else if (digit_u8 == 5u8) { digit = 5i64; }
                else if (digit_u8 == 6u8) { digit = 6i64; }
                else if (digit_u8 == 7u8) { digit = 7i64; }
                else if (digit_u8 == 8u8) { digit = 8i64; }
                else if (digit_u8 == 9u8) { digit = 9i64; }
                num = num * 10i64 + digit;
                i = i + 1;
            }
            tokens[tok_count].ty = TOK_NUMBER();
            tokens[tok_count].value = num;
            tok_count = tok_count + 1;
        } else if (text[i] == '+') {
            tokens[tok_count].ty = TOK_PLUS();
            tokens[tok_count].value = 0i64;
            tok_count = tok_count + 1;
            i = i + 1;
        } else if (text[i] == '-') {
            tokens[tok_count].ty = TOK_MINUS();
            tokens[tok_count].value = 0i64;
            tok_count = tok_count + 1;
            i = i + 1;
        } else if (text[i] == '*') {
            tokens[tok_count].ty = TOK_STAR();
            tokens[tok_count].value = 0i64;
            tok_count = tok_count + 1;
            i = i + 1;
        } else if (text[i] == '/') {
            tokens[tok_count].ty = TOK_SLASH();
            tokens[tok_count].value = 0i64;
            tok_count = tok_count + 1;
            i = i + 1;
        } else if (text[i] == '%') {
            tokens[tok_count].ty = TOK_PERCENT();
            tokens[tok_count].value = 0i64;
            tok_count = tok_count + 1;
            i = i + 1;
        } else if (text[i] == '(') {
            tokens[tok_count].ty = TOK_LPAREN();
            tokens[tok_count].value = 0i64;
            tok_count = tok_count + 1;
            i = i + 1;
        } else if (text[i] == ')') {
            tokens[tok_count].ty = TOK_RPAREN();
            tokens[tok_count].value = 0i64;
            tok_count = tok_count + 1;
            i = i + 1;
        } else {
            printf("Lexer error: unknown character '%c'\n", text[i]);
            tokens[tok_count].ty = TOK_ERROR();
            tokens[tok_count].value = 0i64;
            tok_count = tok_count + 1;
            i = i + 1;
        }
    }
    
    if (tok_count < max_tokens) {
        tokens[tok_count].ty = TOK_EOF();
        tokens[tok_count].value = 0i64;
        tok_count = tok_count + 1;
    }
    
    return tok_count;
}
